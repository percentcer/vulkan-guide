#version 460

struct Particle {
  vec2 pos;
  vec2 vel;
  vec4 color;
  vec4 data1; // <_, _, _, _>
  vec4 data2; // <_, _, _, _>
};

layout (local_size_x = 256) in;

layout (rgba16f, set = 0, binding = 0) uniform image2D image;
layout (std430, set = 0, binding = 1) buffer ParticleData {
  Particle particles[];
};

// push constants block
layout( push_constant ) uniform constants
{
  vec4 data1;
  vec4 data2;
  vec4 data3;
  vec4 data4;
} PushConstants;

void main() 
{
  uint index = gl_GlobalInvocationID.x;
	ivec2 size = imageSize(image);
  float dt = PushConstants.data1.x;

  vec2  attr0Pos = PushConstants.data2.xy;
  float attr0Str = PushConstants.data2.z;
  vec2  attr1Pos = PushConstants.data3.xy;
  float attr1Str = PushConstants.data3.z;

  vec2 position = particles[index].pos;
  vec2 velocity = particles[index].vel;

  vec2 a0Fp = (attr0Pos - position);
  vec2 a1Fp = (attr1Pos - position);
  float falloff0 = 1./dot(a0Fp,a0Fp);
  float falloff1 = 1./dot(a1Fp,a1Fp);
  vec2 a0 = a0Fp * falloff0 * attr0Str;
  vec2 a1 = a1Fp * falloff1 * attr1Str;

  vec2 newVelocity = velocity + a0 + a1;
  vec2 newPosition = position + dt * newVelocity;

  // if (newPosition.x > 1. || newPosition.x < 0.) newVelocity.x *= -1.;
  // if (newPosition.y > 1. || newPosition.y < 0.) newVelocity.y *= -1.;
  // newPosition = mod(newPosition, vec2(1,1));

  particles[index].pos = newPosition;
  particles[index].vel = newVelocity;

  ivec2 imagePosition = ivec2(newPosition * size);

  if(imagePosition.x < size.x && imagePosition.y < size.y)
  {
      imageStore(image, imagePosition, vec4(smoothstep(0,1,length(newVelocity)),smoothstep(1,2,length(newVelocity)),1.0,1.0));
  }
}
